const sheetURL =
        "https://docs.google.com/spreadsheets/d/1RrgLJ5nfgdJ2AzKRaDhOqeIcsLBO0G1W9g7Lj0Z0W5Q/gviz/tq?tqx=out:csv";

      d3.csv(sheetURL).then((data) => {
        console.log("âœ… Raw Data Loaded:", data);

        // Trim and clean up column names
        data = data.map((d) => ({
          "MÃ£ Ä‘Æ¡n hÃ ng": d["MÃ£ Ä‘Æ¡n hÃ ng"].trim(),
          "Thá»i gian táº¡o Ä‘Æ¡n": d["Thá»i gian táº¡o Ä‘Æ¡n"].trim(),
          "MÃ£ máº·t hÃ ng": d["MÃ£ máº·t hÃ ng"].trim(),
          "TÃªn máº·t hÃ ng": d["TÃªn máº·t hÃ ng"].trim(),
          "MÃ£ nhÃ³m hÃ ng": d["MÃ£ nhÃ³m hÃ ng"].trim(),
          "TÃªn nhÃ³m hÃ ng": d["TÃªn nhÃ³m hÃ ng"].trim(),
          "ThÃ nh tiá»n": +d["ThÃ nh tiá»n"],
          month: new Date(d["Thá»i gian táº¡o Ä‘Æ¡n"]).getMonth() + 1,
          group: `[${d["MÃ£ nhÃ³m hÃ ng"]}] ${d["TÃªn nhÃ³m hÃ ng"]}`,
          order: d["MÃ£ Ä‘Æ¡n hÃ ng"].trim(),
        }));

        console.log("âœ… Processed Data:", data);

        // Process Data for "Doanh sá»‘ theo Máº·t hÃ ng"
        let itemSales = d3.rollup(
          data,
          (v) => d3.sum(v, (d) => d["ThÃ nh tiá»n"]),
          (d) => `${d["MÃ£ máº·t hÃ ng"]} - ${d["TÃªn máº·t hÃ ng"]}`
        );
        itemSales = Array.from(itemSales, ([key, value]) => ({
          item: key,
          revenue: value,
        }));
        itemSales.sort((a, b) => b.revenue - a.revenue);
        console.log("âœ… Item Sales Data:", itemSales);

        // Process Data for "Doanh sá»‘ theo NhÃ³m hÃ ng"
        let groupSales = d3.rollup(
          data,
          (v) => d3.sum(v, (d) => d["ThÃ nh tiá»n"]),
          (d) => `${d["MÃ£ nhÃ³m hÃ ng"]} - ${d["TÃªn nhÃ³m hÃ ng"]}`
        );
        groupSales = Array.from(groupSales, ([key, value]) => ({
          group: key,
          revenue: value,
        }));
        groupSales.sort((a, b) => b.revenue - a.revenue);
        console.log("âœ… Group Sales Data:", groupSales);

        // Process Data for "Doanh sá»‘ theo ThÃ¡ng"
        let monthSales = d3.rollup(
          data,
          (v) => d3.sum(v, (d) => d["ThÃ nh tiá»n"]),
          (d) => {
            let date = new Date(d["Thá»i gian táº¡o Ä‘Æ¡n"]);
            return isNaN(date) ? "Unknown" : date.getMonth() + 1;
          }
        );
        monthSales = Array.from(monthSales, ([month, value]) => ({
          month,
          revenue: value,
        }));
        monthSales = monthSales.filter((d) => d.month !== "Unknown");
        monthSales.sort((a, b) => a.month - b.month);
        console.log("âœ… Month Sales Data:", monthSales);

        // Process Data for "XÃ¡c suáº¥t bÃ¡n hÃ ng theo NhÃ³m hÃ ng"
        let totalOrders = new Set(data.map((d) => d["MÃ£ Ä‘Æ¡n hÃ ng"])).size;
        let groupOrderCount = d3.rollup(
          data,
          (v) => new Set(v.map((d) => d["MÃ£ Ä‘Æ¡n hÃ ng"])).size, // Count unique orders per group
          (d) => `${d["MÃ£ nhÃ³m hÃ ng"]} - ${d["TÃªn nhÃ³m hÃ ng"]}`
        );

        let groupOrderProb = Array.from(groupOrderCount, ([key, value]) => ({
          group: key,
          probability: value / totalOrders,
        }));
        groupOrderProb.sort((a, b) => b.probability - a.probability);
        console.log("âœ… Group Order Probability Data:", groupOrderProb);

        // Remove invalid months
        data = data.filter((d) => !isNaN(d.month));

        // Unique orders per month
        let totalOrdersPerMonth = d3.rollup(
          data,
          (v) => new Set(v.map((d) => d.order)).size,
          (d) => d.month
        );

        // Unique orders per NhÃ³m hÃ ng per month
        let groupOrdersPerMonth = d3.rollup(
          data,
          (v) => new Set(v.map((d) => d.order)).size,
          (d) => d.month,
          (d) => d.group
        );

        // Convert to array format
        let formattedData = [];
        groupOrdersPerMonth.forEach((groups, month) => {
          groups.forEach((count, group) => {
            formattedData.push({
              month: `T${month}`, // Format as "T01", "T02", ...
              group,
              probability: count / (totalOrdersPerMonth.get(month) || 1),
            });
          });
        });

        // Step 1: Group orders by NhÃ³m hÃ ng and Máº·t hÃ ng
        let totalOrdersByGroup = d3.rollup(
          data,
          (v) => new Set(v.map((d) => d["MÃ£ Ä‘Æ¡n hÃ ng"])).size, // Count unique orders per NhÃ³m hÃ ng
          (d) => `${d["MÃ£ nhÃ³m hÃ ng"]} - ${d["TÃªn nhÃ³m hÃ ng"]}`
        );

        let itemOrderCount = d3.rollup(
          data,
          (v) => new Set(v.map((d) => d["MÃ£ Ä‘Æ¡n hÃ ng"])).size, // Count unique orders per Máº·t hÃ ng within each NhÃ³m hÃ ng
          (d) => `${d["MÃ£ nhÃ³m hÃ ng"]} - ${d["TÃªn nhÃ³m hÃ ng"]}`,
          (d) => `${d["MÃ£ máº·t hÃ ng"]} - ${d["TÃªn máº·t hÃ ng"]}`
        );

        // Step 2: Compute probability for each Máº·t hÃ ng inside each NhÃ³m hÃ ng
        let groupItemProbabilities = new Map();
        itemOrderCount.forEach((items, group) => {
          let totalOrders = totalOrdersByGroup.get(group) || 1; // Avoid division by zero
          let itemProbabilities = Array.from(items, ([item, count]) => ({
            item: item,
            probability: count / totalOrders,
          }));
          groupItemProbabilities.set(group, itemProbabilities);
        });

        console.log("âœ… Group Item Probabilities:", groupItemProbabilities);

        // Step 3: Create a chart for each NhÃ³m hÃ ng
        const chartContainer = d3.select("#chart9");
        const width = 600,
          height = 300,
          margin = { top: 30, right: 50, bottom: 80, left: 200 };

        // Loop through each NhÃ³m hÃ ng (group) and create a chart
        groupItemProbabilities.forEach((items, group) => {
          console.log(`Group: ${group}, Items:`, items);

          let validItems = items.filter(
            (d) => d.probability !== undefined && d.item
          );
          if (validItems.length === 0) {
            console.warn(`âš  No valid data for group: ${group}`);
            return; // Skip rendering if no valid data
          }

          let sanitizedGroup = group.replace(/[^a-zA-Z0-9-_]/g, ""); // Sanitize ID
          let chartDiv = chartContainer.append("div").attr("class", "chart");

          chartDiv.append("h3").text(group);

          let svg = chartDiv
            .append("svg")
            .attr("id", `chart-${sanitizedGroup}`)
            .attr("width", width)
            .attr("height", height);

          drawBarChart(
            validItems,
            `#chart-${sanitizedGroup}`,
            "item",
            "horizontal",
            width,
            height
          );
        });

      //Q10
      // Step 1: Group orders by NhÃ³m hÃ ng, Máº·t hÃ ng, and ThÃ¡ng
      let totalOrdersByGroupMonth = d3.rollup(
        data,
        (v) => new Set(v.map((d) => d["MÃ£ Ä‘Æ¡n hÃ ng"])).size, // Count unique orders per NhÃ³m hÃ ng per ThÃ¡ng
        (d) => `${d["MÃ£ nhÃ³m hÃ ng"]} - ${d["TÃªn nhÃ³m hÃ ng"]}`,
        (d) => d.month
      );

      let itemOrderCountByMonth = d3.rollup(
        data,
        (v) => new Set(v.map((d) => d["MÃ£ Ä‘Æ¡n hÃ ng"])).size, // Count unique orders per Máº·t hÃ ng within each NhÃ³m hÃ ng per ThÃ¡ng
        (d) => `${d["MÃ£ nhÃ³m hÃ ng"]} - ${d["TÃªn nhÃ³m hÃ ng"]}`,
        (d) => d.month,
        (d) => `${d["MÃ£ máº·t hÃ ng"]} - ${d["TÃªn máº·t hÃ ng"]}`
      );

      // Step 2: Compute probability for each Máº·t hÃ ng inside each NhÃ³m hÃ ng per ThÃ¡ng
      let groupItemProbabilitiesByMonth = new Map();
      itemOrderCountByMonth.forEach((months, group) => {
        let monthProbabilities = new Map();
        months.forEach((items, month) => {
          let totalOrders = totalOrdersByGroupMonth.get(group)?.get(month) || 1; // Avoid division by zero
          let itemProbabilities = Array.from(items, ([item, count]) => ({
            item: item,
            month: month,
            probability: count / totalOrders,
          }));
          monthProbabilities.set(month, itemProbabilities);
        });
        groupItemProbabilitiesByMonth.set(group, monthProbabilities);
      });

      console.log("âœ… Group Item Probabilities by Month:", groupItemProbabilitiesByMonth);

      // Step 3: Create a line chart for each NhÃ³m hÃ ng by Month
      const chartContainer10 = d3.select("#chart10");
      const width10 = 600,
        height10 = 300,
        margin10 = { top: 30, right: 50, bottom: 80, left: 200 };

      // Loop through each NhÃ³m hÃ ng (group) and create a line chart
      groupItemProbabilitiesByMonth.forEach((items10, group10) => {
        console.log(`Group: ${group10}, Items:`, items10);

        let validItems = items10.filter(
          (d) => d.probability !== undefined && d.item
        );
        if (validItems.length === 0) {
          console.warn(`âš  No valid data for group: ${group10}`);
          return; // Skip rendering if no valid data
        }

        let sanitizedGroup = group10.replace(/[^a-zA-Z0-9-_]/g, ""); // Sanitize ID
        let chartDiv = chartContainer10.append("div").attr("class", "chart");

        chartDiv.append("h3").text(group10);

        let svg = chartDiv
          .append("svg")
          .attr("id", `chart-${sanitizedGroup}`)
          .attr("width", width10)
          .attr("height", height10);

        drawLineChart(
          validItems,
          `#chart-${sanitizedGroup}`,
          width10,
          height10
        );
      });
        // Draw Charts
        drawBarChart(itemSales, "#chart1", "item", "horizontal");
        drawBarChart(groupSales, "#chart2", "group", "horizontal");
        drawBarChart(monthSales, "#chart3", "month", "vertical");
        drawBarChart(groupOrderProb, "#chart7", "group", "horizontal");

        // Group data by NhÃ³m hÃ ng
        let groupedData = d3.group(formattedData, (d) => d.group);

        // Draw the line chart
        drawLineChart(groupedData, "#chart8");
      });

      // Function to Draw Bar Charts
      function drawBarChart(
        data,
        chartID,
        labelKey,
        orientation,
        width = 800,
        height = 600
      ) {
        const margin = { top: 20, right: 50, bottom: 80, left: 250 };
        const svg = d3.select(chartID);

        // Remove previous elements before redrawing
        svg.selectAll("*").remove();

        let xScale, yScale;
        let valueKey =
          data[0].probability !== undefined ? "probability" : "revenue"; // Auto-detect key

        if (orientation === "horizontal") {
          xScale = d3
            .scaleLinear()
            .domain([0, d3.max(data, (d) => d[valueKey])]) // No NaN values
            .range([margin.left, width - margin.right]);

          yScale = d3
            .scaleBand()
            .domain(data.map((d) => d[labelKey]))
            .range([margin.top, height - margin.bottom])
            .padding(0.3);

          // Draw bars
          svg
            .selectAll("rect")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", margin.left)
            .attr("y", (d) => yScale(d[labelKey]))
            .attr("width", (d) => xScale(d[valueKey]) - margin.left)
            .attr("height", yScale.bandwidth())
            .attr("fill", (d, i) => d3.schemeCategory10[i % 10]); // Different colors

          // Add x-axis
          let xAxis = d3.axisBottom(xScale).ticks(5);

          // Format as percentage **ONLY** for probability-based charts
          if (valueKey === "probability") {
            xAxis.tickFormat(d3.format(".0%"));
          }

          svg
            .append("g")
            .attr("transform", `translate(0, ${height - margin.bottom})`)
            .call(xAxis);

          // Add y-axis
          svg
            .append("g")
            .attr("transform", `translate(${margin.left}, 0)`)
            .call(d3.axisLeft(yScale));
        } else {
          // Vertical bar chart (for revenue)
          xScale = d3
            .scaleBand()
            .domain(data.map((d) => d[labelKey]))
            .range([margin.left, width - margin.right])
            .padding(0.3);

          yScale = d3
            .scaleLinear()
            .domain([0, d3.max(data, (d) => d.revenue)])
            .range([height - margin.bottom, margin.top]);

          // Draw bars
          svg
            .selectAll("rect")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", (d) => xScale(d[labelKey]))
            .attr("y", (d) => yScale(d.revenue))
            .attr("width", xScale.bandwidth())
            .attr("height", (d) => height - margin.bottom - yScale(d.revenue))
            .attr("fill", "orange");

          // Add x-axis
          svg
            .append("g")
            .attr("transform", `translate(0, ${height - margin.bottom})`)
            .call(d3.axisBottom(xScale));

          // Add y-axis (No percentage formatting here!)
          svg
            .append("g")
            .attr("transform", `translate(${margin.left}, 0)`)
            .call(d3.axisLeft(yScale));
        }
      }

      function drawLineChart(groupedData, chartID, width = 800, height = 600) {
        const 
          margin = { top: 40, right: 150, bottom: 50, left: 80 };
        const svg = d3
          .select(chartID)
          .attr("width", width)
          .attr("height", height);

        // Remove previous elements before redrawing
        svg.selectAll("*").remove();

        // Flatten data for scales
        const allData = [...groupedData.values()].flat();

        // Define scales
        const xScale = d3
          .scalePoint()
          .domain([...new Set(allData.map((d) => d.month))])
          .range([margin.left, width - margin.right]);

        const yScale = d3
          .scaleLinear()
          .domain([0, d3.max(allData, (d) => d.probability) * 1.1])
          .range([height - margin.bottom, margin.top]);

        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

        // Draw X & Y axis
        svg
          .append("g")
          .attr("transform", `translate(0, ${height - margin.bottom})`)
          .call(d3.axisBottom(xScale))
          .selectAll("text")
          .style("text-anchor", "middle");

        svg
          .append("g")
          .attr("transform", `translate(${margin.left}, 0)`)
          .call(d3.axisLeft(yScale).ticks(5).tickFormat(d3.format(".0%"))); // Format as percentage

        // Draw gridlines
        svg
          .append("g")
          .attr("class", "grid")
          .attr("transform", `translate(${margin.left}, 0)`)
          .call(
            d3
              .axisLeft(yScale)
              .tickSize(-width + margin.left + margin.right)
              .tickFormat("")
          );

        // Draw line for each NhÃ³m hÃ ng
        groupedData.forEach((values, group) => {
          let line = d3
            .line()
            .x((d) => xScale(d.month))
            .y((d) => yScale(d.probability))
            .curve(d3.curveLinear); // ðŸ”¹ STRAIGHT LINES, NO CURVES

          svg
            .append("path")
            .datum(values)
            .attr("fill", "none")
            .attr("stroke", colorScale(group))
            .attr("stroke-width", 2)
            .attr("d", line);

          // Add dots
          svg
            .selectAll(`.dot-${group}`)
            .data(values)
            .enter()
            .append("circle")
            .attr("cx", (d) => xScale(d.month))
            .attr("cy", (d) => yScale(d.probability))
            .attr("r", 4)
            .attr("fill", colorScale(group))
            .attr("stroke", "white")
            .attr("stroke-width", 1);
        });

        // Add legend
        let legend = svg
          .append("g")
          .attr(
            "transform",
            `translate(${width - margin.right + 10}, ${margin.top})`
          );
        let legendEntries = [...groupedData.keys()];

        legendEntries.forEach((group, i) => {
          legend
            .append("circle")
            .attr("cx", 0)
            .attr("cy", i * 20)
            .attr("r", 5)
            .attr("fill", colorScale(group));

          legend
            .append("text")
            .attr("x", 10)
            .attr("y", i * 20 + 5)
            .text(group)
            .attr("font-size", "12px")
            .attr("alignment-baseline", "middle");
        });
      }